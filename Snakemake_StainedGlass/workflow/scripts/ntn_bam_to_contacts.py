#!/usr/bin/env python

from __future__ import print_function

import argparse
import sys

import pysam


def parse_extra_alignments(extra_field):
    """
    Parse the additional alignments field of a SAM file

    :param extra_field: The 'XA' field of a SAM file (e.g. "XA:Z:NC_000913.3,+2729620,22M,0;NC_000913.3,+3427225,22M,0;")
    :return: A list of tuples representing the positions of the additional alignments
    """
    extra_field = extra_field[5:]
    alignments = extra_field.strip(";").split(";")
    alignment_positions = []

    for alignment in alignments:
        parts = alignment.split(",")

        seq = parts[0]
        strand = parts[1][0]
        pos = int(parts[1][1:])

        alignment_positions += [(seq, pos)]
        # print("extra alignment:", seq, strand, pos, file=sys.stderr)

    return alignment_positions


def parse_read_id(read_id):
    """
    Parse a read_id into a sequence, strand, position tuple.

    :param read_id: A read id (e.g. "NC_000913.3_-_3061809")
    :return: (sequence, strand, position) tuple e.g. ('NC_000913.3','-','3061809')
    """
    parts = read_id.split(":")
    parts1 = parts[-1].split("-")
    return (":".join(parts[:-1]), "+", int(parts1[0]))


def main():
    parser = argparse.ArgumentParser(
        description="""
    
    python parse_sam.py [filename/-]

    Parse a SAM file generated by bwa aln and output in the format:

    chr1 1000 1001 chr2 2000 2001 1

    So that it can loaded by the cooler package.
"""
    )

    parser.add_argument("input_file", default="-")

    args = parser.parse_args()

    if args.input_file == "-":
        f = sys.stdin
    else:
        f = open(args.input_file, "rb")

    for line in f:
        if line[0] == "@":
            # comment
            continue
        else:
            parts = line.split()
            try:
                read_id = parts[0]
                alignment_flag = int(parts[1])
                if alignment_flag == 0:
                    mapped_strand = "+"
                elif alignment_flag == 16:
                    mapped_strand = "-"
                mapped_seq = parts[2]
                mapped_pos = parts[3]
                mapq = int(parts[4])
            except IndexError as ie:
                print("bad line:", line, file=sys.stderr)
                continue

            if alignment_flag == 4:
                # not aligned
                continue

            original_location = parse_read_id(read_id)
            alignments = [(mapped_seq, mapped_pos)]

            # look for additional alignments
            for extra_field in parts[11:]:
                if extra_field[:2] == "XA":
                    # print('extra field:', extra_field, file=sys.stderr)
                    alignments += parse_extra_alignments(extra_field)

            for (mapped_seq, mapped_pos) in alignments:
                print(
                    "{}\t{}\t{}\t{}\t{}\t{}\t1".format(
                        original_location[0],
                        original_location[2],
                        int(original_location[2]) + 1,
                        mapped_seq,
                        mapped_pos,
                        int(mapped_pos) + 1,
                    )
                )


if __name__ == "__main__":
    main()
